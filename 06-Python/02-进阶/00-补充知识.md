# 装饰器(难点)

1. 本质
> 其实就是定义内外函数，把原函数作为参数传递给外函数，返回内函数的地址
> 
>   在内函数中调用原函数，并且把参数传给原函数

2. 示例：
```python
def outer(func):
def inner(*args, **kwargs):
    # 添加要修改的功能
    func(*args, **kwargs)
    return inner

@outer	#@外函数
def 原函数(参数):
    print("这是原函数！")
```

# 偏函数

# 变量的作用域

1. 类型
> 1.局部作用域(函数作用域)
> 
> 2.全局作用域
> 
> 3.内建作用域

# 栈 & 队列

1. 栈
> 先进后出
> 
> 可以用列表模拟

2. 队列：先进先出
> 1. 导入模块
> 
> `import collections`
> 
> 2. 创建一个队列
> 
> `queue = collections.deque()`  #空队列
> 
> 3. 进队(存数据)
> 
> `queue.append("要压入的内容")`  #将内容压入队列
> 
> 4. 出队(取数据)
> 
> `res = queue.popleft()`  #弹出数据，`res`接收

# 递归

1. 递归调用：一个函数，调用了自身，称为递归调用

2. 递归函数：一个会调用自身的函数称为递归函数

3. 凡是循环能干的事，递归也能干，但是有时候会麻烦

4. 写递归函数的方法
> 1. 写出临界条件
> 
> 2. 找这一次和上一次的关系
> 
> 3. 假设当前函数已经能用，调用自身计算上一次的结果，再求出本次的结果

# 断言(开发中基本不会用)
```python
def funcA(num, div):
    # 括号中为真，则执行后面的内容，否则报错
    # div不能为0
    assert (div != 0)
    return num / div
```




