<img src='./00-images/unit6img1.png' align='left'>


# 一、概述

1. 在`PHP`中不能使用函数重载，所以不能定义重名的函数，也包括不能和系统函数同名。

2. 在`PHP`中可以在函数的声明之后调用，也可以在函数的声明之前调用，还可以在函数中调用函数。

3. 通常在函数中使用`return`语句可以很容易地返回一个值。如果需要返回多个值，则不能采用连续写多个`return`语句的方式。因为函数执行到第一个`return`语句就会退出，不会执行其后面的任何代码。但**可以将多个值添加到一个数组中，再使用`return`返回这个数组，在调用函数时就可以接收到这个数组，并在程序中像使用其他数组一样。**

4. 不能用`return $num1, $num2;`的方式返回多个值。

5. 从`PHP 7`开始，增加了对返回类型声明的支持。返回类型声明指明了函数返回值的类型，现在可用的类型基本上都可以作为返回值类型使用。

```php
function funName() :类型 {函数体}
```

6. 在`PHP 7`中引入的其他返回值类型的基础上，一个新的返回值类型`void`被引入，返回值为`NULL`类型。返回值声明为`void`类型之后，要么省去`return`语句，要么使用一个空的`return`语句（对于`void`函数来说，`null`不是一个合法的返回值），就不允许返回其他类型的数据了。

7. 试图获取一个`void`方法的返回值会得到`null`，并且不会产生任何警告。这么做的原因是不想影响更高层次的方法。

8. 获取实参的引用类型：**获取实参的引用地址是通过运用`&`在形参上提取的**

```php
function funName(&$num1, &$num2) :void {
	if($num1 == $num2) {
		return;  //返回值类型为void，则返回一个空return或者直接省略return语句
	}
	$tmp = $num1;
	$num1 = $num2;
	$num2 = $num1;
}
```

9. 因为`PHP`是弱类型编程语言，不允许在声明变量时加上类型限制。但**在`PHP 5`中可以在函数的形参中加上类型声明了，会对不符合预期的参数进行强制类型转换。在`PHP 5`中只能是类名、接口、`array`或者`callable`。从`PHP 7`开始，函数中的形参类型声明可以是标量，即现在也可以使用`string`、`int`、`float`和`bool`类型了。**形参被限定类型后，接收实参时会把实参转换为形参所指定的类型。

10. 严格模式：

- 不管是限制参数的类型，还是限制返回值的类型，`PHP`有两种处理模式：一种是强制模式（默认），会对不符合预期的参数进行强制类型转换；另一种是严格模式，这个模式下则触发`TypeError`的致命错误。**强制模式是不需要设置的**，默认是如果没有声明为严格模式，值不是预期的类型，`PHP`还是会对其进行强制类型转换。

- 要使用严格模式，`PHP 7`增加了一个`declare`指令：`strict_types`，**声明该指令必须放在文件的顶部。**

- 严格模式意味着，形参限定为什么类型的参数，实参则只能传递该指定类型的参数，否则报错。**使用严格模式后，不强制类型转换，而会出发一个`TypeError`的`Fatal error`，终止程序运行。**

```php
declare(strict_types = 1);
```



# 二、变量作用域

1. 局部变量：

- 是函数内部的变量，一种是形参，一种是函数内部定义的参数。作用域都限于函数内部。

- 每次函数被调用时，函数内部的变量才被声明，执行完毕后函数内部的变量都被释放。

- 如果在函数外部需要调用该变量值，必须通过`return`指令将其值传回至主程序区块以做后续处理。

2. 全局变量：

- 全局变量也称为外部变量，是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。

- 和其他编程语言不同，全局变量不是自动设置为可用的。在`PHP`中，由于函数可以视为单独的程序片段，所以局部变量会覆盖全局变量的能见度，因此**在函数中无法直接调用全局变量。**

- 在函数中若要使用全局变量，必须要利用`global`关键字来定义目标变量，以告诉函数主体此变量为全局变量。

- 在函数中使用全局变量，除了使用关键字`global`，还可以用特殊的`PHP`自定义`$GLOBALS`数组。

- 在`$GLOBALS`数组中，每一个变量是一个元素，键名对应变量名，值对应变量的内容。`$GLOBALS`之所以在全局范围内存在，是因为它是一个超全局变量。

```php+HTML
<body>
	<?php
		$one = 1;
		$two = 2;
		function add () {
			// 在函数中，无法直接使用全局变量
			echo "运算结果是：".@($one + $two)."<br>";
		}
		add();
		function sum () {
			global $one, $two;
			echo "运算结果是：".@($one + $two)."<br>";
		}
		sum();
		function total () {
			// 使用PHP自定义$GLOBALS数组
			echo "运算结果是：".@($GLOBALS['one'] + $GLOBALS['two']);
		}
		total();
	?>
</body>
```


3. 静态变量：

- 局部变量从存储方式上可分为动态存储类型和静态存储类型。函数中的局部变量，如不专门声明为`static`存储类别，默认都是动态地分配存储空间的。其中的内部动态变量在函数调用结束后自动释放。如果希望在函数执行后，其内部变量依然保存在内存中，应使用静态变量。**在函数执行完毕后，静态变量并不会消失，而是在所有对该函数的调用之间共享，即在函数再次执行时，静态变量将接续前次的结果继续运算**，并且**仅在脚本的执行期间函数第一次被调用时被初始化。要声明函数变量为静态的，需用关键字`static`。**



# 三、形参类型

1. 在声明函数时，如果参数能接受多种不同但并不必须是所有类型的值，在函数的说明文档中就可以使用`mixed`标记这个参数类型。如果说明一个参数可以是`integer`或`float`，就可以使用`number`标记参数。

2. 引用传递相对于按值传递模式，并不会将父程序中的指定数值或目标变量传递给函数，而是把该数值或变量的内存存储区块相对地址导入函数之中。因此，当该数值在函数中有任何变动时，会连带对父程序造成影响。如果想要函数的一个参数总是通过引用传递，则在函数定义中，在参数的前面预先加上符号`&`即可。

3. 如果在函数的形参中有使用`&`修饰的参数，则在调用该函数时就必须传入一个变量给这个参数，而不能传递一个值。

4. 在数组处理函数中的`next()`、`sort()`、`shuffle`、`key()`等函数都是引用参数的函数。

5. 在`PHP`中，支持函数的默认方式调用，即为参数指定一个默认值。在调用函数时如果没有指定参数的值，在函数中会使用参数的默认值。默认值必须是常量表达式，不能是变量、类成员或者函数调用。`PHP`还允许使用数组和特殊类型`NULL`作为默认参数。

6. 当调用函数传递参数时，实参和形参是按顺序对应传递数据的，如果实参个数少于形参，则最右边的形参不会被传值。当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧，否则可能函数将不会按照预期的情况工作。

7. 如果希望函数可以接受任意数量的参数，则需要在函数中使用`PHP`系统提供的**`func_get_args()`**函数，它将所有传递给脚本函数的参数当作一个数组返回。除此之外，还可以使用**`func_num_args()`**函数返回参数的总数，使用**`func_get_arg()`**函数接受一个数字参数，返回指定的参数。

```php+HTML
<body>
	<?php
		/**
		* 虽然more_args()没有声明任何形参，但是可以传入任意个数实参，实参通过func_get_args()获得
		*/
		function more_args () {
			// 返回一个数组，包括所有实参
			$args = func_get_args();
			// count()计算实参的个数
			for($i = 0; $i < count($args); $i++) {
				echo "第".$i."个参数是：".$args[$i]."<br>";
			}
			// 通过func_num_args()获得实参个数
			for ($i = 0; $i < func_num_args(); $i++) {
				// 通过func_get_arg()获得实参数组指定下标的元素
				echo "第".$i."个参数是：".func_get_arg($i)."<br>";
			}
		}
		more_args('one', 'two', 'three', 1, 2, 3);
	?>
</body>
```

8. 从`PHP 5.6`以后，可以不依赖`func_get_args()`函数，使用`…`运算符来实现变长参数函数。只要在声明函数的参数时前面加上`…`，就可以实现在调用函数时，传递不同个数的参数，这个形参就会成为数组。另外，在调用函数时，还可以使用`…`运算符，将数组和可遍历的对象展开为函数参数。这个功能非常实用，当一个函数参数比较多时，可以不用逐一地传递参数，在调用函数时，只要传递一个数组，数组中的成员就展开为函数的参数了。

```php+HTML
<body>
	<?php
		// 可以用...接收可变参数，同时还可以限定形参类型，以及返回值类型
		function more_args (int ...$args) :int {
			// array_sum()函数计算数组的和
			return array_sum($args);
		}
		$nums = [1, 2, 3, 4];
		// 传递实参时，可以用...将数组展开传递给形参
		$result = more_args(...$nums);
		echo "计算结果是：".$result."<br>";
		function add ($num1, $num2, $num3, $num4, $num5) {
			return $num1 + $num2 + $num3 + $num4 + $num5;
		}
		// 传递实参时，用...将数组展开，一一对应传递给形参
		$result = add(5, ...$nums);
		echo "计算结果是：".$result."<br>";
	?>
</body>
```


9. 在过去如果我们调用一个用户定义的函数时，提供的参数不足，那么将会产生一个警告（`warning`）。现在`PHP 7`以后的版本，这个警告被提升为一个错误异常（`Error exception`）。该变更仅对用户定义的函数生效，并不包含内置函数。**对用户自定义函数，如果实参个数少于形参，`PHP 7`将报错。**



# 四、回调函数

1. 所谓的回调函数，就是指调用函数时并不是传递一个标准的变量作为参数，而是将另一个函数作为参数传递到调用的函数中。如果在函数的格式说明中出现`callback`类型的参数，则该函数就是回调函数。`callback`也属于`PHP`中伪类型的一种，说明函数的参数需要接受另一个函数作为实参。一个很重要的问题是：为什么要使用函数作为参数呢？前面介绍过，通过参数的传递可以改变调用函数的执行行为，但有时仅将一个值传递给函数能力还是有限的。如果可以将一个用户定义的“执行过程”传递到函数中使用，就大大增加了用户对函数功能的扩展。

2. **变量函数**：变量函数也称为可变函数。如果一个变量名后有圆括号，`PHP`将寻找与变量的值同名的函数，并且将尝试执行它。**变量函数调用要带`$`符号。**

```php+HTML
<body>
	<?php
		function add ($num1, $num2) {
			return $num1 + $num2;
		}
		$sum = "add";
		echo "$sum";    // 直接打印$sum，那么就输出字符串add
		echo $sum(1, 2);  // 在$sum后面加上()，那么就会调用对应$sum变量值$add的同名函数$add()
	?>
</body>
```

3. 结合使用变量函数和回调函数：

```php+HTML
<body>
	<?php
		// 定义一个函数，接收另一个回调函数作为参数，回调函数就像一个普通变量一样使用，只需要加上()
		function filter ($fun) {
			for ($i = 0; $i < 100; $i++) {
				if ($fun($i)) {
					continue;
					echo "$i";
				}
				echo "第".$i."个数字是：".$i."<br>";
			}
		}
		// 定义回调函数
		function filter_three ($num) {
			if ($num % 3 == 0) {
				return true;
			}
		}
		// 把回调函数同名的字符串作为实参传递给父函数
		filter("filter_three");
	?>
</body>
```

4. 虽然可以使用变量函数声明自己的回调函数，但最多的还是通过`call_user_func_array()`函数去实现。**`call_user_func_array()`**函数是`PHP`中的内置函数，其实它也是一个回调函数。该函数有两个参数：第一个参数因为使用伪类型`callback`，所以这个参数需要是一个字符串，表示要调用的函数名；第二个参数是一个数组类型的参数，表示参数列表，按照顺序依次传递给要调用的函数。**回调函数的形参必须声明为接收任意数量的参数，实参不需用`…`展开。**


```php+HTML
<body>
	<?php
		function func (...$nums) {
			for ($i = 0; $i < count($nums); $i++) {
				if ($nums[$i] % 2 == 0) {
					continue;
				}
				echo "$nums[$i]<br>";
			}
		}
		call_user_func_array("func", [1,2,3,4,5,6,7,8,9,10]);
	?>
</body>
```


5. 类静态函数和对象的方法回调：

- `callback("函数名称字符串");`  // 回调全局函数，`callback`回调函数可以是自定义的，也可以是系统函数如`call_user_fun_array()`函数等。

- `callback(array("类名称字符串", "类中静态方法名称字符串"), array(数组元素));`  // 回调类中的静态成员方法。

- `callback(array(对象引用, "对象中方法名称字符串"));`  // 回调对象中的成员方法。

```php+HTML
<body>
	<?php
		// 声明一个类Demo，类中声明一个静态的成员方法fun()
		class Demo {
			static function fun ($num1, $num2) {
				$result = $num1 + $num2;
				echo "计算结果是：".$result."<br>";
			}
		}
		/**
		* 通过系统函数call_user_func_array()调用Demo类中的静态方法
		* 回调类中的静态成员方法：第一个参数必须使用数组，并且这个数组需要指定两个元素
		* 第一个元素为类名称的字符串，第二个元素为该类中的静态方法名称字符串
		* 第二个参数也是一个数组，这个数组中每个元素值会按顺序传递给调用Demo类中的fun()方法的形参
		*/
		call_user_func_array(array("Demo", "fun"), array(1, 2));
		// 声明一个类，类中声明一个普通的成员方法fun()
		class Test {
			function fun ($num1, $num2) {
				$result = $num1 * $num2;
				echo "计算结果是：$result<br>";
			}
		}
		/**
		* 通过系统函数call_user_func_array()调用Test类的实例对象中的成员方法fun()
		* 回调类中的成员方法：第一个参数必须使用数组，并且这个数组需要指定两个元素
		* 第一个元素为对象引用，在本例中也可以是$obj=new Test()中的$obj，第二个元素则是该对象中成员方法名称字符串
		* 第二个参数也是一个数组，这个数组中每个元素值会按顺序传递给调用new Test()对象中的fun()方法的形参列表
		*/
		call_user_func_array(array(new Test(), "fun"), array(2, 3));
	?>
</body>
```


# 五、递归函数

1. 递归函数即自调用函数，在函数体内部直接或间接地自己调用自己，即函数的嵌套调用是函数本身。通常在此类型的函数体中会附加一个条件判断叙述，以判断是否需要执行递归调用，并且在特定条件下终止函数的递归调用动作，把目前流程的主控权交回上一层函数执行。


# 六、函数库

1. 收集函数定义的文件就是创建的`PHP`函数库。如果在`PHP`的脚本中想使用这些文件中定义的函数，就需要使用`include()`、`include_once()`、`require()`或`require_once()`中的一个函数，将函数库文件载入到脚本程序中。

2. `require()`语句的性能与`include()`类似，都是包括并运行指定文件。不同之处在于，对`include()`语句来说，在执行文件时每次都要进行读取和评估；而对于`require()`语句来说，文件只处理一次（实际上，文件内容替换了`require()`语句）。这就意味着如果可能执行多次的代码，则使用`require()`效率比较高。另外，如果每次执行代码时读取不同的文件，或者有通过一组文件迭代的循环，就使用`include()`语句。

3. `require()`语句的使用方法，如`require("myfile.php")`这条语句通常放在`PHP`脚本程序的最前面，`PHP`程序在执行前就会先读入`require()`语句所引入的文件，使它变成`PHP`脚本文件的一部分。`include()`语句的使用方法和`require()`语句一样，如`include("myfile.php")`，而这条语句一般放在流程控制的处理区段中。`PHP`脚本文件在读到`include()`语句时，才将它包含的文件读进来。

4. `require()`和`include()`语句是语言结构，不是真正的函数，可以像`PHP`中其他语言结构一样。`require()`和`include()`语句也可以不加圆括号而直接加参数，例如`include`语句可以使用`include("file.php")`包含`file.php`文件，也可以使用`include "file.php"`形式。

5. `include_once()`和`require_once()`语句在脚本执行期间包括并运行指定文件。此行为和`include()`及`require()`语句类似，使用方法也一样。唯一区别是：如果该文件中的代码已经被包括了，则不会再次包括。这两条语句应该用于在脚本执行期间，同一个文件有可能被包括超过一次的情况下，确保它只被包括一次，以避免函数重定义及变量重新赋值等问题。


# 七、匿名函数(闭包函数)

1. `PHP 5.3`以前的回调函数使用并不是很灵活的，只有“字符串的函数名”和“使用`create_function`的返回值”两种选择。而在`PHP 5.3`以后，我们又多了一个选择——匿名函数（`Anonymous functions`），也叫闭包函数（`closures`），它允许临时创建一个没有指定名称的函数，常用作回调函数参数的值。

```php+HTML
<body>
	<?php
		// 将一个没有名字的函数赋值给一个变量$fun
		$fun = function ($demo) {
			echo "$demo";
		};  // 一定要记得加;
		// 变量名后加()并传参数，调用匿名函数
		$fun("这是一个匿名函数示例<br>");
		// 匿名函数作为变量的值使用，最常用。把匿名函数传递给回调函数，然后直接调用回调函数
		function callback ($callback) {
			$callback();
		}
		callback(function () {
			echo "匿名函数，亦即闭包函数";
		});
	?>
</body>
```


2. 闭包的一个重要概念就是在内部函数中可以使用外部变量，需要通过关键字`use`来连接闭包函数和外界变量，这些变量都必须在函数或类的头部声明。闭包函数是从父作用域中继承变量，与使用全局变量是不同的。全局变量存在于一个全局的范围，无论当前正在执行的是哪个函数。而闭包的父作用域是定义该闭包的函数，不一定是调用它的函数。

- **即闭包函数可以通过`use`使用调用函数所在的同级变量。**


```php+HTML
<body>
	<?php
		// 声明一个函数，接收一个回调函数
		function fun ($callback) {
			$callback();
		}
		$msg = "原来的变量！";
		/**
		* 闭包函数可以使用外部变量，通过use关键字才能实现
		* use引用的是$msg的副本，如果要完全引用，那就需要用&$msg形式
		*/
		fun(function () use ($msg) {
			$msg = "变量内容被改变了！<br>";
			echo "$msg";
		});
		echo $msg;
	?>
</body>
```

