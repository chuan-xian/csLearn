# 概述

## JS是单线程的

1. JS中的代码都是串行的，前面没有执行完毕后面不能执行。

2. 执行顺序：
    - 程序运行会从上至下依次执行所有的同步代码。
    - 在执行的过程中如果遇到异步代码会将异步代码放到事件循环中。
    - 当所有同步代码都执行完毕后，JS会不断检测事件循环中的异步代码是否满足条件。
    - 一旦满足条件就执行满足条件的异步代码。

## 宏任务和微任务

1. 在JS的异步代码中，区分宏任务和微任务，宏任务是比较费时、比较慢的任务，微任务相对较快、费时少。

2. 常见的宏任务和微任务：
    - MacroTask：setTimeout、setInterval、setImmediate(IE独有)...
    - microTask：Promise、MutationObserver、process.nextTick(Node独有)...
    - 注意：所有的宏任务和微任务都会放到自己的执行队列中，也就是有一个宏任务队列和一个微任务队列，所有放到队列中的任务都采用“先进先出原则”，也就是多个任务同时满足条件，那么先放进去的先执行。

3. 宏任务和微任务的执行顺序：
    - 从上至下执行所有的同步代码。
    - 在执行过程中遇到宏任务就放到宏任务队列中，遇到微任务就放到微任务队列中。
    - 当所有的同步代码执行完毕后，就执行微任务队列中满足需求的所有回调。
    - 党微任务队列中所有满足需求的回调执行完毕后，就执行宏任务队列中满足需求的所有回调。
    - 每执行完一个宏任务都会立即检查微任务队列中有无微任务，有则立即执行。(有的宏任务中包含微任务)

## NodeJS之eventloop

1. NodeJS事件循环和浏览器事件循环区别：
    - 任务队列个数不同：
        - 浏览器事件循环有2个事件队列(宏任务队列和微任务队列)。
        - NodeJS事件循环有6个队列。
    - 微任务队列不同：
        - 浏览器事件循环中有专门存储微任务的队列。
        - NodeJS事件循环中没有专门存储微任务的队列。
    - 微任务执行时机不同：
        - 浏览器事件循环中，每执行完一个宏任务都会去执行清空微任务队列。
        - NodeJS事件循环中，只有同步代码执行完毕，或者其它队列之间切换的时候会清空微任务队列。
    - 微任务优先级不同：
        - 浏览器事件循环中，如果多个微任务同时满足执行条件，采用先进先出。
        - NodeJS事件循环中，如果多个微任务同时满足执行条件，会按照优先级执行

2. NodeJS中的任务队列：
    - timers：执行setTimeout()和setInterval()中到期的callback。
    - pending callbacks：执行系统操作的回调，如tcp、udp通信的错误callback。
    - idle，prepare：只在内部使用。
    - poll：执行与I/O相关的回调。(除了close回调、定时器回调和setImmediate()之外，几乎所有回调都执行)
    - check：执行setImmediate()的callback。
    - close callback：执行close事件的callback，例如socket.on('close', func)。

3. 注意点：
    - 和浏览器不同的是，没有宏任务和微任务队列的概念。
    - 宏任务被放到了不同的队列中，但是没有队列是存储微任务的队列。
    - 微任务会在执行完同步代码和队列切换的时候执行。
    - process.nextTick微任务的优先级高于Promise.resolve。

4. 什么时候切换队列？
    - 当队列为空(已经执行完毕或者没有满足条件的回调)
    - 执行的回调函数数量达到系统设定的阈值时，任务队列就会切换。

5. 阻塞：
    - 执行完poll，查看check队列是否有内容，有就切换到check。
    - 如果check队列没有内容，就会查看timers是否有内容，有就切换到timers。
    - 如果check和timers队列都没有内容，为了避免资源浪费，就会阻塞在poll