# 一、参数


1. 函数的两种声明方式：

- 利用函数关键字自定义函数（命名函数）：`function funName () {}`。
- 利用函数表达式自定义函数（匿名函数）：`var 变量名 = function() {}`。例如`var fun = function(){}`中`fun`是变量名，不是函数名。


2. 函数的默认参数，可以是直接指定的，也可以是函数返回的：
```javascript
function getSum(a = 1, b = getNum()) {
    return a + b;
}

function getNum() {
    return 2;
}

let res = getSum(22);
console.log(res);
```

3. 函数是一种引用变量，所以函数名就相当于一个变量，可以作为参数和返回值，调用的时候加上括号即可。

4. 在其它编程语言中，函数不可以嵌套定义。在`JavaScript`中，函数可以嵌套定义。

5. 函数形参和实参匹配问题：

| 实参个数等于形参     | 输出正确结果                              |
| -------------------- | ----------------------------------------- |
| 实参个数多余形参个数 | 形参正常接收，多余的实参丢弃              |
| 实参个数少于形参个数 | 对应的形参接收实参，其余的形参为undefined |

6. **return只能返回一个值，如果返回值写了多个，则实际返回值以最后一个为准。**

7. **如果函数没有返回值，那么默认返回undefined。**

8. **arguments**的使用：

- 当我们不确定有多少个参数传递的时候，可以用`arguments`来获取。在`JavaScript`中，`arguments`实际上是当前函数的一个内置对象，所有函数都内置了一个`arguments`对象，`arguments`对象中存储了传递的所有实参。

- `arguments`展示的是一个伪数组，因此可以进行遍历。伪数组具有以下特点： 
	- 具有`length`属性。
	- 按索引方式存储数据。
	- 不具有数组的`push`、`pop`等方法。


# 二、匿名函数

1. 有名函数两种定义方式
```javascript
function say () {
    console.log('hello world!');
}

let say = function () {
    console.log('hello world');
}
```

2. 匿名不能只定义不使用，定义后必须使用。
	- 作为其它函数的参数；
	- 作为其它函数的返回值；
	- 作为一个立即执行函数。


# 三、作用域

## 1. 作用域分类

1. 局部作用域

- 和函数结合使用，就是函数后面的的{}所包括的范围。
```javascript
	function test() {
		console.log('局部作用域');  // 函数中{}所包括的范围为局部作用域
	}
```
- 对象中：`Object o = {}`。
  
2. 块级作用域
    - 也是`{}`所包括的范围，但是不包含函数的`{}`所包括的范围。
    - 一般包括普通`{}`、`for(;;){}`、`do{}while()`、`switch(){}`、`if(){}`等。
    
3. 全局作用域
   
    - 以整个文件为作用域。

## 2. `JavaScript`中定义变量的两种方式

1. `var`是`ES6`之前声明变量的关键字。`let`是`ES6`之后声明变量的关键字。

2. `ES6`之前：`var`
- 如果通过`var`定义变量，可以重复定义同名的变量，并且不会报错。后定义的变量会覆盖先定义的变量。
- 变量可以先调用再定义，因为有预解析，所以程序可以运行。这种变量中一般存储的是`undefined`。
- 通过`var`在局部作用域中定义的变量是局部变量。在函数外部（全局作用域范围）以及块级作用域中定义的变量为全局变量。
- 全局变量在布局作用域中会被局部变量覆盖，可以通过`window.全局变量名`来访问全局变量。
  
3. `ES6`开始：`let`
- 如果通过`let`定义变量，不可以重复定义同名的变量。
- 不可以先调用再定义，因为浏览器不会对`let`定义的变量进行预解析。
- 通过`let`定义的变量区分全局变量和局部变量。
- `let`不论是局部作用域还是块级作用域都是局部变量，只有在全局作用域中定义的变量才是全局变量。

4. 无论在块级作用域还是局部作用域，省略变量前的`let`或者`var`都是全局变量。


## 3. 全局变量 vs 局部变量

1. 全局变量
    - 全局变量就是定义在`{}`外面的变量。

2. 局部变量
    - 局部变量就是定义在`{}`里面的变量。

3. 全局变量和局部变量的区别：
    - 如果是全局变量，不论是通过`var`定义还是`let`定义，都是从定义处开始，直到文件结尾处。
    - 如果是局部变量，则是从定义处开始，到`{}`结尾处(只能在`{}`内使用)。

4. 在开发中要注意循环中的变量定义。
```javascript
let num = 1;
do {
    // num必须定义在外面，否则while将无法调用let定义的局部变量
    // let num = 0;
    num++;
    console.log(num);
} while (num > 10);
```

4. 在`ES6`之前没有块级作用域，只有局部作用域和全局作用域。


## 4. 补充

1. 通常来说，一段程序代码中所用到的名字(变量)并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字的冲突；

2. 作用域将变量分为全局变量和局部变量：

- 全局变量：在全局作用域下的变量，在全局可以使用。或者是在函数内部，没有通过`var`声明、而是直接赋值的变量也是全局变量；
- 局部变量：在函数或者代码块内部的变量。函数的形参也是局部变量；



# 三、作用域链

1. 作用域链：内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构称为作用域链，查找的方法是就近原则：
	- 在当前作用域中、调用处之前查找，找到就用当前作用域的变量；
	- 如果当前作用域中没有，就去上一级作用域中、当前作用域之前查找；
	- 以此类推直到0级为止，如果0级作用域还没有找到，则报错。



# 四、预解析


## 1. 概述

1. `JavaScript`代码是由浏览器中的`JavaScript`解析器来执行的，`JavaScript`解析器在运行`JavaScript`代码的时候分为两步：预解析和代码执行。

2. 在`ES6`之前会对变量和函数预解析，预解析`js`引擎会把`js`里面的所有`var`还有`function`提升到当前作用域的最前面，然后代码按照从上往下的的顺序执行。规则如下：
	- 在同级作用域种，从上至下先把变量、函数预解析；
	- 其余步骤按照从上至下再执行。
	- 作用域按照从外到内的作用域链进行多层预解析。

## 2. 变量预解析

1. 变量预解析：即变量提升，就是把所有的变量声明提升到当前的作用域最前面，但是不提升赋值操作。

```javascript
// 运行结果为`undefined`   
console.log(num);
var num =  10;

// 等价于以下代码，提升变量的声明部分，但不提升赋值操作
var num;
console.log(num);
num = 10;
```


## 2. 函数预解析

1. 函数预解析：就是把所有的函数声明提升到当前作用域的最前面，不调用函数。

2. 函数定义有三种方式，前两种会被预解析，第三种通过`let`定义的不会被预解析。

- 正常预解析，可以先使用后定义：
```javascript
demo();
function demo() {
    console.log('hello world');
}

/**
// 预解析后
// demo()函数整体就是一个声明，预解析把声明提前，其余按照原顺序解析执行
function demo() {
    console.log('hello wordl');
}
demo();
*/
```

- 正常预解析，但不可以先调用后定义：
```javascript
demo();  // 报错
var demo = function () {
    console.log('hello world');
}

/**
// 函数先预解析
var demo;
// 其余部分正常解析执行
demo();  // 报错，因为demo仅是一个undefined的变量，并没有预解析为一个函数
function () {
    console.log('hello world');
}
*/
```

3. 通过`let`定义，不会预解析，更不能先调用后定义。

4. 函数和变量同名时，函数的优先级高于变量

5. 函数预解析的内容为第97-99节视频

- **var a = b = c = 9;等价于var a = 9; b = 9; c = 9; // b和c就是全局变量了;**

# 五、函数与`===`

1. `===`可以判断两个函数名称，表示两个函数是否都存储在同一块内存中。注意：只判断两个函数是否存储在同一内存中，而不是判断两个函数是否同名等。

